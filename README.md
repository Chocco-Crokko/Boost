# Глава 32. Boost.Asio

**Содержание**

<hr>

+ [Способы и объекты ввода-вывода](#ioservices)  
+ [Масштабируемость и Многопоточность](#threads)  
+ [Сетевое программирование](#network)  
+ [Сопрограммы](#coroutines)  
+ [Специфика объектов ввода-вывода](#iospecific)  

<hr>

В этой главе рассматривается библиотека [Boost.Asio](http://www.boost.org/doc/libs/1_62_0/doc/html/boost_asio.html). Asio используется для асинхронного ввода - вывода. Эта библиотека позволяет обрабатывать данные в асинхронном режиме. Асинхронный режим означает, что когда операции инициируются, инициирующей программе не нужно ждать их завершения. Вместо этого Boost.Asio уведомляет программу, когда операция закончилась. Преимуществом является то, что другие операции могут быть выполнятся параллельно.  

Boost.Thread еще одна библиотека, которая позволяет выполнять операции одновременно. Разница между Boost.Thread и Boost.Asio заключается в том, что с Boost.Thread вы получаете доступ к ресурсам внутри программы, а с Boost.Asio вы получаете доступ к ресурсам за пределами программы. Например, если вы разрабатываете функцию, которую требуется запустить для трудоемких вычислений, можете вызвать эту функцию в потоке, а его запустить на другом ядре процессора. Потоки позволяют вам получить доступ к процессору и использовать его ядра. С точки зрения вашей программы, ядра процессора являются внутренним ресурсом. Если же вы хотите получить доступ к внешним ресурсам, использйте Boost.Asio.

Сетевые соединения являются примером внешних ресурсов. Если данные должны быть отправлены или получены, сетевая карта выполняет определнные операции. Для операции передачи, сетевая карта получает указатель на буфер с данными для отправки. Для операции получения, сетевая карта получает указатель на буфер, который заполняется поступившими данными. Поскольку сетевая карта является внешним ресурсом для вашей программы, она может выполнять операции независимо. Для этого необходимо только время, которое вы могли бы использовать для выполнения иных задач. Boost.Asio позволяет более эффективно использовать доступные устройства путем использования свойства выполнять операции одновременно.  

Передача и прием данных по сети реализована в виде асинхронной операции в Boost.Asio. Считайте асинхронную операцию функцией, которая сразу завершается, но без какого-либо результата. Результат передается позже.  

На первом этапе асинхронная операция запускается. На втором этапе программа получает уведомление, когда асинхронная операция закончилась. Такое разделение между началом и завершением позволяет получить доступ к внешним ресурсам без блокировки вызовов функций. 

<a name="ioservices"></a>
# Объекты ввода - вывода

Программы, которые используют Boost.Asio для асинхронной обработки данных, основаны на **сервисе** и **объектах ввода - вывода**. Сервис ввода - вывода - это абстрактный интерфейс операционной системы, который обрабатывает данные в асинхронном режиме. Объекты ввода - вывода инициируют асинхронные операции. Эти два понятия необходимы для разделения задач: сервисы ввода - вывода использую API операционной системы, а объекты ввода - вывода общаются с разработчиком.

Как пользователь Boost.Asio вы не подключаетесь напрямую к сервисам ввода - вывода, а управляете ими с помощью объектов ввода - вывода. Объект сервиса ввода - вывода можно представить как список, в котором перечислены сервисы ввода - вывода. Каждый объект знает свой сервис и получает к нему доступ через объект сервиса ввода - вывода.

Boost.Asio содержит ```boost::asio::io_service``` - класс для объекта сервиса ввода - вывода. Каждая программа, основанная на Boost.Asio, использует объект типа ```boost::asio::io_service```. Этот объект может объявляться глобально.

Для объекта сервиса ввода - вывода существует единственный класс, а для объектов ввода - вывода существует несколько классов. Поскольку ввод - вывод может быть использован для различных целей, класс, который необходимо использовать зависит от поставленной задачи. Например, если взаимодействие будет происходить по TCP/IP протоколам, то нужно использовать объект типа ```boost::asio::ip::tcp::socket```. Если данные должны быть переданы асинхронно через определенный порт, то используйте ```boost::asio::serial_port```. Для временного соединения используется ```boost::asio::steady_timer```.  
  
```boost::asio::steady_timer``` можно ассоциировать с будильником. Заблокированная функция завершится по окончанию времени в таймере и сообщит об этом. ```boost::asio::steady_timer``` просто ждет завершения установленного времени, но внешние ресурсы являются не доступнымы. Однако эти ресурсы видны через операционную систему, чтобы уведомить основной поток о завершении выполнения. Эта операция освобождает программу от создания нового потока для вызова блокирующей фукции. ```boost::asio::steady_timer``` - очень простой для использования объект. 

*Заметка*:  
Из-за ошибки в Boost.Asio, не представляется возможным составить некоторые из следующих примеров с использованием Clang. Описание ошибки лежит здесь [ticket 8835](https://svn.boost.org/trac/boost/ticket/8835). В качестве решения замените ```std::chrono``` на ```boost::chrono```, то сможете скомпилировать примеры и с Clang.

<a name="example321"></a>
Пример 32.1. Используется ```boost::asio::steady_timer```

```c++
#include <boost/asio/io_service.hpp>
#include <boost/asio/steady_timer.hpp>
#include <chrono>
#include <iostream>
    
using namespace boost::asio;

int main()
{
  io_service ioservice;
  
  steady_timer timer{ioservice, std::chrono::seconds{3}};
  timer.async_wait([](const boost::system::error_code &ec)
    { std::cout << "3 sec\n"; });

  ioservice.run();
}
```

В [Примере 32.1](#example321) создается объект сервиса ввода - вывода - **ioservice**, и используется для инициализации **таймера** (одного из типов объектов ввода - вывода). Объекты ```boost::asio::steady_timer``` ожидают объект сервиса ввода - вывода в качестве первого параметра в конструкторе. Поскольку **таймер** представляет собой будильник, он может быть передан вторым параметром в конструктор, который определяет конкретное время или период времени, когда будильник должен 'зазвонить'. В [примере 32.1](#example321), будильник установлен на 3 секунды. Отсчет времени начинается с определения **таймера**.

Вместо вызова блокирующей функции, которая будет возвращаться, когда будильник зазвонит, Boost.Asio позволяет начать асинхронную операцию. Чтобы это сделать, вызовите функцию ```async_wait()```, которая ожидает обработчик в качестве единственного параметра. Обработчик является функцией или функциональным объектом, который вызывается, когда асинхронная операция завершается. В [примере 32.1](#example321) в качестве параметра передается лямбда - функция.

Лямбда функция вызовется только через 3 секунды. Когда ```async_wait()``` возвращает управление, программа может сделать что-то еще.

```async_wait()``` является неблокирующей функцией. Объекты ввода - вывода, как правило, могут обеспечивать блокирование функций. Например, вы можете вызвать функцию блокировки ```wait()``` в ```boost::asio::steady_timer```. Поскольку эта функция просто блокирует, она не принимает никакого обработчика. ```wait()``` завершается либо в определенное время, либо после какого - то периода.

В конце функции ```main()``` в [примере 32.1](#example321) вызывается метод ```run()``` объекта сервиса ввода - вывода. Этот вызов необходим, поскольку функционирующие системные функции должны взять на себя контроль. Следует помнить, что сервис ввода - вывода в объекте, который реализует асинхронные операции, основанные на использовании функций операционной системы.

В то время как ```async_wait()``` инициирует асинхронную операцию и немедленно возвращается, ```run()``` блокируется. Многие операционные системы поддерживают асинхронные операции только через функцию блокировки. Следующий пример показывает, почему это, как правило, не является проблемой.

<a name="example322"></a>
Пример 32.2. Две асинхронные операции с ```boost::asio::steady_timer```

```c++
#include <boost/asio/io_service.hpp>
#include <boost/asio/steady_timer.hpp>
#include <chrono>
#include <iostream>

using namespace boost::asio;

int main()
{
  io_service ioservice;

  steady_timer timer1{ioservice, std::chrono::seconds{3}};
  timer1.async_wait([](const boost::system::error_code &ec)
    { std::cout << "3 sec\n"; });

  steady_timer timer2{ioservice, std::chrono::seconds{4}};
  timer2.async_wait([](const boost::system::error_code &ec)
    { std::cout << "4 sec\n"; });

  ioservice.run();
}
```

В [примере 32.2](#example322) используются два объекта типа ```boost::asio::steady_timer```. Первым объектом ввода - вывода является таймер, который ждет три секунды. Второй ждет в течение четырех секунд. После того, как период времени истекает, вызывается лямбда - функция, которая была передана в ```async_wait()```.

```run()``` вызывается только для объекта сервиса ввода - вывода в этом примере. Этот вызов передает управление функциям операционной системы, которые выполняют асинхронные операции. С их помощью, первая лямбда - функция вызывается через три секунды, а вторая в течение четырех.

Может казаться неожиданностью, что асинхронные операции требуют вызова функции блокировки. Тем не менее, это не является проблемой, так как программа должна быть защищена от выхода. Если ```run()``` не будет блокирован, ```main()``` вернется, и программа завершится. Если вы не хотите ждать завершения ```run()```, просто запустите его в новом потоке.

После того, как все таймеры завершили ожидание, никаких асинхронных операций, которые программа должна ожидать, больше нет.  

<a name="threads"></a>
# Масштабируемость и Многопоточность  

Разработка программы, основанной на библиотеке как Boost.Asio отличается от обычного стиля C ++. Функции, на которые может понадобиться достаточно много времени, нет смысла вызывать в последовательном порядке. Вместо вызова блокирущих функций, Boost.Asio запускает асинхронные операции. Функции, которые должны быть вызваны после завершения операции теперь вызываются без соответствующего обработчика. Недостатком данного данного подхода является разделение последовательно выполняемых функций, что может сделать код трудным для понимания.

Такие библиотеки как Boost.Asio обычно используются для достижения большей эффективности. При этом нет необходимости ждать завершения функции, программа может выполнять в этот момент другие задачи. Таким образом, можно запустить несколько асинхронных операций, которые все выполняются одновременно. Но помните, что асинхронные операции, как правило, используются для доступа к ресурсам за пределами процесса. Поскольку ресурсы могут быть различными устройствами, они могут работать независимо друг от друга и выполнять операции параллельно.

Масштабируемость характеризует способность программы эффективно использовать дополнительные ресурсы. Если используются потоки,  то несколько функций выполняются одновременно на доступных ядрах процессора. Boost.Asio с потоками улучшает масштабируемость, поскольку программа может взаимодействовать с внутренними и внешними ресурсами, которые могут выполняться самостоятельно или в сотрудничестве друг с другом.

Если функция ```run()``` вызывается для объекта типа ***boost::asio::io_service***, связанные с ним обработчики вызываются в том же потоке. При использовании нескольких потоков, программа может вызвать ```run()``` несколько раз. После того, как асинхронная операция завершена, объект сервиса ввода - вывода будет запускать обработчик в одном из этих потоков. Если вторая операция завершается вскоре после первого, объект может запустить обработчик в другом потоке. Однако, не только операции могут выполняться параллельно за пределами процессора, но и обработчики внутри также могут быть выполнены одновременно.    
 
<a name="example323"></a>
Пример 32.3. Два потока объектов сервиса ввода - вывода для параллельного выполнения обработчиков

```c++
#include <boost/asio/io_service.hpp>
#include <boost/asio/steady_timer.hpp>
#include <chrono>
#include <thread>
#include <iostream>

using namespace boost::asio;

int main()
{
  io_service ioservice;

  steady_timer timer1{ioservice, std::chrono::seconds{3}};
  timer1.async_wait([](const boost::system::error_code &ec)
    { std::cout << "3 sec\n"; });

  steady_timer timer2{ioservice, std::chrono::seconds{3}};
  timer2.async_wait([](const boost::system::error_code &ec)
    { std::cout << "3 sec\n"; });

  std::thread thread1{[&ioservice](){ ioservice.run(); }};
  std::thread thread2{[&ioservice](){ ioservice.run(); }};
  thread1.join();
  thread2.join();
}
```

Предыдущий пример был преобразован в многопоточную программу, описанный в [примере 32.3](#example323). С помощью ```std::thread``` были созданы два потока в функции ```main()```. ```run()``` вызывается для каждого объекта ввода - вывода в обоих потоках. Это делает возможным для объекта службы ввода / вывода, чтобы использовать обе нити для выполнения обработчиков, когда асинхронные операции завершена. Когда асинхронные операции завершаются, запускаются два потока, в которых выполняются параллельно обработчики.

В [примере 32.3](#example323), оба таймера должны завершиться три секунды. Поскольку два потока доступны, обе лямбда - функции будут выполняться одновременно. Если второй таймер завершится в то время как обработчик первого выполняется, второй обработчик будет запущен в оставшемся потоке. Если к этому моменту первый обработчик уже завершит свое выполнение, то второй может выбирать любой поток.

Конечно, не всегда имеет смысл использовать потоки. [Пример 32.3](#example323) не может писать последовательно в стандартный поток вывода. Они могут быть перепутаны. Оба обработчика, которые могут выполняться в двух потоках одновременно, используют один глобальный ресурс **std::cout**. Чтобы избежать коллизий, доступ к **std::cout** должен быть синхронизированным. Преимущество потоков теряется, если обработчики не могут выполняться одновременно.

<a name="example324"></a>
Пример 32.4. Один поток для каждого объекта сервиса ввода - вывода для параллельного выполнения обработчиков  

```c++
#include <boost/asio/io_service.hpp>
#include <boost/asio/steady_timer.hpp>
#include <chrono>
#include <thread>
#include <iostream>

using namespace boost::asio;

int main()
{
  io_service ioservice1;
  io_service ioservice2;

  steady_timer timer1{ioservice1, std::chrono::seconds{3}};
  timer1.async_wait([](const boost::system::error_code &ec)
    { std::cout << "3 sec\n"; });

  steady_timer timer2{ioservice2, std::chrono::seconds{3}};
  timer2.async_wait([](const boost::system::error_code &ec)
    { std::cout << "3 sec\n"; });

  std::thread thread1{[&ioservice1](){ ioservice1.run(); }};
  std::thread thread2{[&ioservice2](){ ioservice2.run(); }};
  thread1.join();
  thread2.join();
}
```

Рекомендуется несколько раз вызывать метод ```run()``` для одного объекта, поскольку так можно сделать программу более масштабируемой. Вместо создания нескольких потоков для одного объекта сервиса ввода - вывода, можно также создавать несколько объектов.

Два объекта используют два таймера типа ```boost::asio::steady_timer``` в [примере 32.4](#example324). Программа основана на двух потоках, каждый из которых связан с объектом ввода - вывода. Два объекта ввода - вывода **timer1** и **timer2* не привязаны к одному объекту сервиса. Они связаны с различными объектами.

[Пример 32.4](#example324) работает так же, как и раньше. Нельзя сказать когда какой метод лучше использовать. Поскольку ```boost::asio::io_service``` представляет из себя интерфейс операционной системы, а любое решение зависит от конкретного интерфейса.

В операционной системе Windows ```boost::asio::io_service``` обычно основывается на IOCP, в Linux, основан на ```epoll()```. Наличие нескольких объектов ввода - вывода означает, что будет использовано несколько портов или произойдут вызовы ```epoll()```. Только от поставленной задачи зависит использовать только один порт ввода - вывода или один вызов ```epoll()```.
