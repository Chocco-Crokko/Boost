# Глава 32. Boost.Asio

**Содержание**

<hr>

+ [Способы и объекты ввода-вывода](#ioservices)  
+ [Масштабируемость и Многопоточность](#threads)  
+ [Сетевое программирование](#network)  
+ [Сопрограммы](#coroutines)  
+ [Специфика объектов ввода-вывода](#iospecific)  

<hr>

В этой главе рассматривается библиотека [Boost.Asio](http://www.boost.org/doc/libs/1_62_0/doc/html/boost_asio.html). Asio используется для асинхронного ввода - вывода. Эта библиотека позволяет обрабатывать данные в асинхронном режиме. Асинхронный режим означает, что когда операции инициируются, инициирующей программе не нужно ждать их завершения. Вместо этого Boost.Asio уведомляет программу, когда операция закончилась. Преимуществом является то, что другие операции могут быть выполнятся параллельно.  

Boost.Thread еще одна библиотека, которая позволяет выполнять операции одновременно. Разница между Boost.Thread и Boost.Asio заключается в том, что с Boost.Thread вы получаете доступ к ресурсам внутри программы, а с Boost.Asio вы получаете доступ к ресурсам за пределами программы. Например, если вы разрабатываете функцию, которую требуется запустить для трудоемких вычислений, можете вызвать эту функцию в потоке, а его запустить на другом ядре процессора. Потоки позволяют вам получить доступ к процессору и использовать его ядра. С точки зрения вашей программы, ядра процессора являются внутренним ресурсом. Если же вы хотите получить доступ к внешним ресурсам, использйте Boost.Asio.  

Сетевые соединения являются примером внешних ресурсов. Если данные должны быть отправлены или получены, сетевая карта выполняет определнные операции. Для операции передачи, сетевая карта получает указатель на буфер с данными для отправки. Для операции получения, сетевая карта получает указатель на буфер, который заполняется поступившими данными. Поскольку сетевая карта является внешним ресурсом для вашей программы, она может выполнять операции независимо. Для этого необходимо только время, которое вы могли бы использовать для выполнения иных задач. Boost.Asio позволяет более эффективно использовать доступные устройства путем использования свойства выполнять операции одновременно.  

Передача и прием данных по сети реализована в виде асинхронной операции в Boost.Asio. Считайте асинхронную операцию функцией, которая сразу завершается, но без какого-либо результата. Результат передается позже.  

На первом этапе асинхронная операция запускается. На втором этапе программа получает уведомление, когда асинхронная операция закончилась. Такое разделение между началом и завершением позволяет получить доступ к внешним ресурсам без блокировки вызовов функций. 

<a name="ioservices"></a>
# Объекты ввода - вывода

Программы, которые используют Boost.Asio для асинхронной обработки данных, основаны на **сервисе** и **объектах ввода - вывода**. Сервис ввода - вывода - это абстрактный интерфейс операционной системы, который обрабатывает данные в асинхронном режиме. Объекты ввода - вывода инициируют асинхронные операции. Эти два понятия необходимы для разделения задач: сервисы ввода - вывода использую API операционной системы, а объекты ввода - вывода общаются с разработчиком.

Как пользователь Boost.Asio вы не подключаетесь напрямую к сервисам ввода - вывода, а управляете ими с помощью объектов ввода - вывода. Объект сервиса ввода - вывода можно представить как список, в котором перечислены сервисы ввода - вывода. Каждый объект знает свой сервис и получает к нему доступ через объект сервиса ввода - вывода.

Boost.Asio содержит ***boost::asio::io_service*** - класс для объекта сервиса ввода - вывода. Каждая программа, основанная на Boost.Asio, использует объект типа ***boost::asio::io_service***. Этот объект может объявляться глобально.

Для объекта сервиса ввода - вывода существует единственный класс, а для объектов ввода - вывода существует несколько классов. Поскольку ввод - вывод может быть использован для различных целей, класс, который необходимо использовать зависит от поставленной задачи. Например, если взаимодействие будет происходить по TCP/IP протоколам, то нужно использовать объект типа ***boost::asio::ip::tcp::socket***. Если данные должны быть переданы асинхронно через определенный порт, то используйте  ***boost::asio::serial_port***. Для временного соединения используется ***boost::asio::steady_timer***. 

***boost::asio::steady_timer*** можно ассоциировать с будильником. Заблокированная функция завершится по окончанию времени в таймере и сообщит об этом. ***boost::asio::steady_timer*** просто ждет завершения установленного времени, но внешние ресурсы являются не доступнымы. Однако эти ресурсы видны через операционную систему, чтобы уведомить основной поток о завершении выполнения. Эта операция освобождает программу от создания нового потока для вызова блокирующей фукции. ***boost::asio::steady_timer*** - очень простой для использования объект. 

*Заметка*:
    Из-за ошибки в Boost.Asio, не представляется возможным составить некоторые из следующих примеров с использованием Clang. Описание ошибки лежит здесь [ticket 8835](https://svn.boost.org/trac/boost/ticket/8835). В качестве решения замените ***std::chrono*** на ***boost::chrono***, то сможете скомпилировать примеры и с Clang.

Пример 32.1. Используется ***boost::asio::steady_timer***

```c++
    #include <boost/asio/io_service.hpp>
    #include <boost/asio/steady_timer.hpp>
    #include <chrono>
    #include <iostream>
    
    using namespace boost::asio;

    int main()
    {
      io_service ioservice;

      steady_timer timer{ioservice, std::chrono::seconds{3}};
      timer.async_wait([](const boost::system::error_code &ec)
        { std::cout << "3 sec\n"; });

      ioservice.run();
    }
```
